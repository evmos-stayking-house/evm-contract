{
  "language": "Solidity",
  "sources": {
    "contracts/SwapHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nimport './interface/ISwapHelper.sol';\nimport './interface/swap/v2-periphery/IUniswapV2Router.sol';\nimport './interface/swap/core/IUniswapV2Pair.sol';\nimport './lib/utils/SafeToken.sol';\n\ncontract SwapHelper is ISwapHelper {\n    IUniswapV2Router public router;\n\n    constructor(address _router) {\n        router = IUniswapV2Router(_router);\n    }\n\n    function getDy(\n        address tokenX,\n        address tokenY,\n        uint256 dx\n    ) public view override returns (uint256 dy) {\n        address[] memory path = new address[](2);\n        path[0] = tokenX == address(0) ? router.WETH() : tokenX;\n        path[1] = tokenY == address(0) ? router.WETH() : tokenY;\n\n        uint256[] memory amounts = router.getAmountsOut(dx, path);\n        return amounts[1];\n    }\n\n    function getDx(\n        address tokenX,\n        address tokenY,\n        uint256 dy\n    ) public view override returns (uint256 dx) {\n        address[] memory path = new address[](2);\n        path[0] = tokenX == address(0) ? router.WETH() : tokenX;\n        path[1] = tokenY == address(0) ? router.WETH() : tokenY;\n\n        uint256[] memory amounts = router.getAmountsIn(dy, path);\n        return amounts[0];\n    }\n\n    function exchange(\n        address tokenX,\n        address tokenY,\n        uint256 dx,\n        uint256 minDy\n    ) public payable override returns (uint256) {\n        address[] memory path = new address[](2);\n        uint256[] memory amounts;\n\n        // if tokenY == address(0) too, swapExactETHForTokens will be reverted.\n        if (tokenX == address(0)) {\n            require(dx == msg.value, 'exchange: invalid msg.value');\n\n            path[0] = router.WETH();\n            path[1] = tokenY;\n\n            amounts = router.swapExactETHForTokens{value: dx}(\n                minDy,\n                path,\n                msg.sender,\n                block.timestamp + 600 // 10 minutes, 수치는 조절해야 함\n            );\n\n            return amounts[1];\n        }\n        else {\n            /// @dev msg.sender should approve this helper contract first\n            SafeToken.safeTransferFrom(tokenX, msg.sender, address(this), dx);\n\n            SafeToken.safeApprove(tokenX, address(router), dx);\n\n            path[0] = tokenX;\n            path[1] = router.WETH();\n\n            amounts = router.swapExactTokensForETH(\n                dx,\n                minDy,\n                path,\n                msg.sender,\n                block.timestamp + 600 // 10 minutes, 수치는 조절해야 함\n            );\n\n            return amounts[1];\n        }\n    }\n\n    function getPriceImpactBpsFrom(\n        address _pair, \n        uint _token0Amount,\n        uint _token1Amount\n    ) \n        public \n        view \n        returns (uint token0Amount, uint token1Amount, uint reserve0, uint reserve1, uint32 blockTimestampLast) \n    {\n        (reserve0, reserve1, blockTimestampLast) = IUniswapV2Pair(_pair).getReserves();\n        require(block.timestamp > blockTimestampLast, \"timestamp is error\");\n        require(reserve0 > 0 && reserve1 > 0, \"Insufficient Liquidity for the pair input\");\n\n        if(token1Amount == 0) {\n            token1Amount = router.quote(_token0Amount, reserve0, reserve1);\n        } else {\n            token0Amount = router.quote(_token1Amount, reserve1, reserve0);\n        }\n    }\n\n}\n"
    },
    "contracts/interface/ISwapHelper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\n/************************************************************\n * @dev\n * Glossary\n * X : Input Token\n * Y : Output Token\n * Dx : Amount of Input Token\n * Dy : Amount of Output Token\n *************************************************************/\ninterface ISwapHelper {\n    function getDy(\n        address tokenX,\n        address tokenY,\n        uint256 dx\n    ) external view returns (uint256 dy);\n\n    function getDx(\n        address tokenX,\n        address tokenY,\n        uint256 dy\n    ) external view returns (uint256 dx);\n\n    function exchange(\n        address tokenX,\n        address tokenY,\n        uint256 dx,\n        uint256 minDy\n    ) external payable returns (uint256 dy);\n}\n"
    },
    "contracts/interface/swap/v2-periphery/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router {\n\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n    \n}"
    },
    "contracts/interface/swap/core/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/lib/utils/SafeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\nlibrary SafeToken {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            '!safeApprove'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            '!safeTransfer'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            '!safeTransferFrom'\n        );\n    }\n\n    function safeTransferEVMOS(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, '!safeTransferEVMOS');\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}