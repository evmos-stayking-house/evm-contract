{
  "language": "Solidity",
  "sources": {
    "contracts/StayKing.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport 'hardhat/console.sol';\nimport './interface/IStayking.sol';\nimport './interface/IVault.sol';\nimport './interface/ISwapHelper.sol';\nimport './interface/IUnbondedEvmos.sol';\nimport './lib/utils/SafeToken.sol';\nimport './lib/OwnableUpgradeable.sol';\nimport './lib/ReentrancyGuardUpgradeable.sol';\n\ncontract Stayking is IStayking, OwnableUpgradeable, ReentrancyGuardUpgradeable {\n\n    /*************\n     * CONSTANT *\n     **************/\n    address private constant BASE_TOKEN = address(0);\n\n    /*************\n     * EVENTS *\n     **************/\n\n    // Function Events\n    event AddPosition(address indexed user, address indexed vault, uint256 equity, uint256 debtInBase, uint256 debt, uint256 share);\n    event RemovePosition(address indexed user, address indexed vault, uint256 equity, uint256 debtInBase, uint256 debt, uint256 share);\n    event PositionChanged(address indexed user, address indexed vault, uint256 amount, uint256 share, uint256 debt);\n    event Kill(address indexed killer, address indexed user, address vault, uint256 equity, uint256 debtInBase, uint256 debt, uint256 share);\n\n    event Stake(address indexed delegator, address indexed user, uint256 amount, uint256 share);\n    event Unstake(address indexed delegator, address indexed user, uint256 amount, uint256 share);\n\n    event Accrue(address indexed delegator, uint256 accrued, uint256 totalStaked);\n\n    // Operation Events\n    event AddVault(address token, address vault);\n    event ChangeDelegator(address delegator);\n    event ChangeUEVMOS(address uEVMOS);\n    event UpdateVault(address token, address vault);\n    event UpdateConfigs(uint256 minDebtInBase, uint256 reservedBps, uint256 vaultRewardBps, uint256 killFactorBps, uint256 liquidateDebtFactorBps, uint256 liquidationFeeBps);\n\n    /******************\n     * STATE VARIABLES\n     ******************/\n\n    /// @dev 총 EVMOS\n    uint256 public override totalAmount;\n    /// @dev stake/unstake 시점에 유저 포지션의 share 가 가감 되는 총 지분\n    uint256 public override totalShare;\n\n    /// @dev min debtAmount in EVMOS (base token)\n    uint256 public override minDebtInBase;\n    uint256 public override reservedBps;\n    uint256 public override vaultRewardBps;\n    uint256 public override killFactorBps;\n    uint256 public override liquidateDebtFactorBps;\n    uint256 public override liquidationFeeBps;\n\n    /// @dev EVMOS amount reserved by Protocol (매출)\n    uint256 public reservedPool;\n\n    IUnbondedEvmos public uEVMOS;\n    address public delegator;\n    address[] public vaults;\n\n    struct Position {\n        address user;\n        /// @dev share(유저가 스테이크한 시점의 지분) : (equity + debtInBase) * totalShare / totalAmount\n        uint256 share;\n    }\n\n    /// @dev userAddress => vaultAddress => positionId (array Index of position)\n    mapping(address => mapping(address => uint256)) public positionIdOf;\n    /// @dev vaultAddress => Position[]\n    mapping(address => Position[]) public positions;\n    mapping(address => uint256) public positionsLengthOf;\n    /// @dev 청산 봇 Whitelist\n    mapping(address => bool) public whitelistedKiller;\n    mapping(address => address) public override tokenToVault;\n    // debt To Vault\n    mapping(address => uint256) public totalDebtOf;\n\n    /*************\n     * Modifiers *\n     **************/\n    modifier onlyDelegator() {\n        require(\n            // whitelistedDelegator[msg.sender],\n            msg.sender == delegator,\n            'Stayking: Not whitelisted delegator.'\n        );\n        _;\n    }\n\n    modifier onlyKiller() {\n        require(\n            whitelistedKiller[msg.sender],\n            'Stayking: Not whitelisted Killer.'\n        );\n        _;\n    }\n\n    /***\n     * Intialization\n     */\n    function __Stayking_init(address delegator_, address uEVMOS_)\n        external\n        initializer\n    {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n\n        // @TODO 수치는 다시 정해야 함\n        updateConfigs(\n            1e16, // minDebtInBase (0.01EVMOS) 최소 빚 0.01EVMOS\n            3000, // reservedBps 30%\n            2000, // vaultRewardBps 20%\n            7500, // killFactorBps 75%\n            7500, // liquidateDebtFactorBps 75%\n            500 // liquidationFeeBps 5%\n        );\n\n        uEVMOS = IUnbondedEvmos(uEVMOS_);\n        changeDelegator(delegator_);\n        whitelistedKiller[delegator_] = true;\n        whitelistedKiller[msg.sender] = true;\n    }\n\n    /**********************\n     * External Functions *\n     ***********************/\n    function updateVault(address token, address vault) external override onlyOwner {\n        address beforeVault = tokenToVault[token];\n\n        if (beforeVault == address(0)) {\n            vaults.push(vault);\n            emit AddVault(token, vault);\n        } else {\n            require(\n                IVault(beforeVault).totalDebtAmount() == 0,\n                'updateVault: Debt remains on the existing vault.'\n            );\n\n            uint256 vaultsLength = vaults.length;\n            bool vaultReplaced = false;\n            for (uint256 i = 0; i < vaultsLength; i++) {\n                if (vaults[i] == beforeVault) {\n                    vaults[i] = vault;\n                    vaultReplaced = true;\n                    break;\n                }\n            }\n            assert(vaultReplaced);\n            emit UpdateVault(token, vault);\n        }\n\n        tokenToVault[token] = vault;\n        \n        // push null position\n        positions[vault].push(Position({user: address(0), share: 0}));\n\n        positionsLengthOf[vault] = 1;\n    }\n\n    function isKillable(address debtToken, uint256 positionId)\n        external\n        view\n        override\n        returns (bool)\n    {\n        address vault = tokenToVault[debtToken];\n        Position memory p = positions[vault][positionId];\n\n        if (p.share == 0)\n            /// @dev removed position\n            return false;\n        (bool healthy, ) = _isHealthy(\n            vault,\n            p.share,\n            debtAmountOf(p.user, vault)\n        );\n        return !healthy;\n    }\n\n    /********************\n     * Public Functions\n     ********************/\n\n    function changeUnbondedEvmos(address _uevmos) public override onlyOwner {\n        uEVMOS = IUnbondedEvmos(_uevmos);\n        emit ChangeUEVMOS(_uevmos);\n    }\n\n    function changeDelegator(address _delegator) public override onlyOwner {\n        delegator = _delegator;\n        emit ChangeDelegator(_delegator);\n    }\n\n    function updateWhitelistedKillerStatus(address[] calldata killers, bool ok)\n        public\n        onlyOwner\n    {\n        for (uint256 i = 0; i < killers.length; i++) {\n            whitelistedKiller[killers[i]] = ok;\n        }\n    }\n\n    function updateConfigs(\n        uint256 _minDebtInBase,\n        uint256 _reservedBps,\n        uint256 _vaultRewardBps,\n        uint256 _killFactorBps,\n        uint256 _liquidateDebtFactorBps,\n        uint256 _liquidationFeeBps\n    ) public onlyOwner {\n        minDebtInBase = _minDebtInBase;\n        reservedBps = _reservedBps;\n        vaultRewardBps = _vaultRewardBps;\n        killFactorBps = _killFactorBps;\n        liquidateDebtFactorBps = _liquidateDebtFactorBps;\n        liquidationFeeBps = _liquidationFeeBps;\n        emit UpdateConfigs(\n            _minDebtInBase,\n            _reservedBps,\n            _vaultRewardBps,\n            _killFactorBps,\n            _liquidateDebtFactorBps,\n            _liquidationFeeBps\n        );\n    }\n\n    function debtAmountOf(address user, address vault)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return IVault(vault).debtAmountOf(user);\n    }\n\n    /// @param debtToken    debtToken Address (not vault address)\n    /// @param equity       equityAmount in EVMOS\n    /// @param debtInBase   debtAmount in EVMOS\n    function addPosition(\n        address debtToken,\n        uint256 equity,\n        uint256 debtInBase\n    ) public payable override {\n        address vault = tokenToVault[debtToken];\n        require(\n            positionIdOf[msg.sender][vault] == 0,\n            'addPosition: already have position'\n        );\n        require(equity == msg.value, 'addPosition: msg.value != equity');\n\n        uint256 amount = equity + debtInBase;\n        require(\n            debtInBase * 1e4 < amount * killFactorBps,\n            'addPosition: bad debt, cannot open position'\n        );\n\n        // borrow token from vault\n        // debtInBase == 0 -> 1x leverage\n        uint256 debt = debtInBase > 0\n            ? IVault(vault).loan(msg.sender, debtInBase)\n            : 0;\n\n        positions[vault].push(Position({user: msg.sender, share: 0}));\n\n        uint256 positionId = positionsLengthOf[vault];\n        positionsLengthOf[vault] += 1;\n        positionIdOf[msg.sender][vault] = positionId;\n\n        uint256 share = _stake(positions[vault][positionId], amount);\n\n        emit AddPosition(msg.sender, vault, equity, debtInBase, debt, share);\n    }\n\n    /// @dev remove all position of debtToken vault.\n    /// @param debtToken    debtToken Address (not vault address)\n    /// @notice kor) 부채비율이 100%가 넘어가면 포지션을 직접 종료할 수 없다. -> 강제 청산만 가능.\n    function removePosition(address debtToken) public override {\n        address vault = tokenToVault[debtToken];\n        Position storage p = positions[vault][positionIdOf[msg.sender][vault]];\n        require(p.share > 0, 'removePosition: No position for this token');\n\n        uint256 debtAmount = debtAmountOf(msg.sender, vault);\n        // 1. check if user can repay debt\n        /// @dev amount in EVMOS that user have to repay\n        uint256 currentDebtInBase = IVault(vault).getBaseIn(debtAmount);\n\n        uint256 unstakedAmount = shareToAmount(p.share);\n        // unstake all\n        _unstake(p, vault, unstakedAmount, debtAmount, 0);\n\n        /**\n         kor)\n         유저가 스스로 포지션을 종료할 때,\n         부채비율이 100% 이내인 경우만 포지션 종료 가능하도록 제한\n         */\n        require(\n            unstakedAmount >= currentDebtInBase,\n            'removePosition: Bad debt'\n        );\n\n        emit RemovePosition(\n            msg.sender,\n            vault,\n            unstakedAmount - currentDebtInBase, // equity\n            currentDebtInBase, // debt\n            debtAmount,\n            p.share\n        );\n\n        positionIdOf[msg.sender][vault] = 0; // kor) positionId 초기화\n    }\n\n\n    /** @notice change position value\n        case 1. equityInBaseChanged > 0\n            - increase position value (stake more)\n            - decrease debt ratio\n        case 2. equityInBaseChanged < 0\n            - decrease position value (partial close)\n            - increase debt ratio\n        case 3. debtInBaseChanged > 0 (borrow more debt)\n            - increase position value (stake more)\n            - increase debt ratio\n        case 4. debtInBaseChanged < 0 (repay debt by unstaking)\n            - decrease position value (partial)\n            - decrease debt ratio\n        case 5. repaidDebt > 0 or repaidDebtInBase > 0 (repay debt with user's own token/EVMOS)\n            - position value not changes (not call stake/unstake function)\n            - decrease debt ratio\n        @dev repayDebtInBase = msg.value - changeEquityInBase\n        @dev User should approve this first\n        @dev if msg.value > 0, changeEquityInBase >= 0\n             since msg.value = changeEquityInBase + repayDebtInBase\n        @notice\n        If equityInBaseChanged(=A) > 0 and debtInBaseChanged(=B) < 0, it is inefficient.\n            e.g. A = 100 and B = -50, 50 EVMOS is Locked at uEVMOS.\n            it produces the same result as if A = 50 and C = 50.\n        (both increases equity by 50 EVMOS and repay debt by 50 EVMOS)\n        Similarly, the case where equityInBaseChanged < 0 and debtInBaseChanged > 0 are also inefficient.\n        So, we revert all cases where equityInBaseChanged * debtInBaseChanged < 0.\n     */\n    function changePosition(\n        address debtToken,\n        int256 equityInBaseChanged,\n        int256 debtInBaseChanged,\n        uint256 repaidDebt\n    ) public payable {\n        address vault = tokenToVault[debtToken];\n        uint256 positionId = positionIdOf[msg.sender][vault];\n        require(positionId > 0, 'changePosition: no position');\n\n        Position storage p = positions[vault][positionId];\n\n        uint256 repaidDebtInBase;\n        if (equityInBaseChanged >= 0) {\n            // stake more with own equity\n            require(\n                msg.value >= uint256(equityInBaseChanged),\n                'changePosition: Not enough msg.value'\n            );\n            unchecked {\n                repaidDebtInBase = msg.value - uint256(equityInBaseChanged);\n            }\n        }\n\n        (\n            bool isStaking,\n            uint256 equity,\n            uint256 debtInBase,\n            int256 repaidDebtChanged\n        ) = _adjustChangePositionArgs(equityInBaseChanged, debtInBaseChanged);\n\n        if (repaidDebtChanged >= 0) {\n            repaidDebtInBase += uint256(repaidDebtChanged);\n        } else {\n            if (repaidDebtInBase >= uint256(-repaidDebtChanged)) {\n                repaidDebtInBase -= uint256(-repaidDebtChanged);\n            } else {\n                repaidDebtInBase = 0;\n                repaidDebtChanged += int256(repaidDebtInBase);\n            }\n        }\n\n        if (isStaking) {\n            if (debtInBase > 0) {\n                IVault(vault).loan(msg.sender, debtInBase);\n            }\n            _stake(p, equity + debtInBase);\n        } else {\n            // TODO repaidDebtChanged ?\n            uint256 unstakedAmount = equity +\n                debtInBase +\n                (repaidDebtChanged < 0 ? uint256(-repaidDebtChanged) : 0);\n            require(\n                debtInBase * 1E4 <= unstakedAmount * liquidateDebtFactorBps,\n                'unstake: too much debt in unstaked EVMOS'\n            );\n\n            _unstake(\n                p,\n                vault,\n                unstakedAmount,\n                IVault(vault).getTokenOut(debtInBase),\n                0\n            );\n        }\n\n        /******************************************\n           Repay Debt (position value not change)\n         ******************************************/\n        if (repaidDebt > 0) {\n            // repay debt for token, approve should be proceed\n            SafeToken.safeTransferFrom(\n                debtToken,\n                msg.sender,\n                address(this),\n                repaidDebt\n            );\n            IVault(vault).repayInToken(msg.sender, repaidDebt);\n        }\n        if (repaidDebtInBase > 0) {\n            // repay debt for EVMOS\n            IVault(vault).repayInBase{value: repaidDebtInBase}(msg.sender, 1);\n        }\n\n        {\n            uint256 debtAmount = debtAmountOf(msg.sender, vault);\n            (bool healthy, ) = _isHealthy(vault, p.share, debtAmount);\n            require(healthy, 'changePosition: bad debt');\n        }\n\n        emit PositionChanged(\n            msg.sender,\n            vault,\n            shareToAmount(p.share),\n            p.share,\n            debtAmountOf(msg.sender, vault)\n        );\n    }\n\n    /**\n        @dev returns position's value & debt value\n        position value: positionValueInBase\n        equity value: positionValueInBase - debtInBase\n        debt value: debtInBase\n        debt ratio: debtInBase / positionValueInBase * 100(%)\n        kill factor: killFactorBps / 100\n        safety buffer: (kill factor) - (debt ratio)\n     */\n    function getPositionInfo(address user, address debtToken)\n        external\n        view\n        override\n        returns (\n            uint256 positionValueInBase,\n            uint256 debtInBase,\n            uint256 debt,\n            uint256 positionId\n        )\n    {\n        address vault = tokenToVault[debtToken];\n        positionId = positionIdOf[user][vault];\n\n        Position memory p = positions[vault][positionId];\n\n        positionValueInBase = shareToAmount(p.share);\n\n        debt = IVault(vault).debtAmountOf(user);\n        debtInBase = IVault(vault).getBaseIn(debt);\n    }\n\n    // if position is killed, fee will be charged.\n    function kill(address debtToken, uint256 positionId)\n        public\n        override\n        onlyKiller\n    {\n        address vault = tokenToVault[debtToken];\n        Position storage p = positions[vault][positionId];\n        require(p.share > 0, 'kill: removed position');\n\n        uint256 debt = debtAmountOf(p.user, vault);\n        (bool healthy, uint256 debtInBase) = _isHealthy(vault, p.share, debt);\n        require(!healthy, 'kill: still safe position.');\n\n        // unstaked amount\n        uint256 amount = shareToAmount(p.share);\n        uint256 liquidationFee = (amount * liquidationFeeBps) / 1E4;\n        /**\n         @dev\n            강제 청산 시 liquidationFee 를 매출로 잡는다.\n\n            만약 liquidationFee = 5%인 경우, unstake된 이후 pend된 포지션에 대해\n            부채비율이 95%만 넘어가도 lender가 손해를 보게 됩니다.\n\n            _unstake의 4번째 파라미터 값(전체 unstake 되는 양 중 부채가 차지하는 비율)과\n            uEVMOS.mintLockedToken의 4번째 파라미터 값을 조정하여 이를 해소할 수 있습니다.\n         */\n        _unstake(p, vault, amount, debt, liquidationFee);\n\n        emit Kill(\n            msg.sender,\n            p.user,\n            vault,\n            debtInBase > amount ? 0 : amount - debtInBase,\n            debtInBase,\n            debt,\n            p.share\n        );\n\n        positionIdOf[p.user][vault] = 0; // kor) positionId 초기화\n    }\n\n    /***********************\n     * Only for Delegator *\n     ***********************/\n\n    /**\n     @dev msg.value = all of staking reward\n     @notice 수익 분배 순서\n        1. 프로토콜(Stayking) 매출\n          -> 전체 reward 중 (reservedBps / 100)% 만큼\n        2. Vault Interest(정규 이자 calc by interestModel)\n            (1) \"전체 reward 중 N%\"가 아닌 고정된 양이므로, 남은 reward로는 interest를 지급하지 못할 수 있다.\n                이 경우, (전체 reward - 매출) 전량을 Vault Interest로 지급.\n            (2) 정상적인 경우 (매출을 제외한) reward가 Vault Interest보다 크다.\n        3. Vault reward / Reinvested Amount\n            2-(2)의 경우 reward에서 매출/이자를 제하고 남은 금액 중 (vaultRewardBps / 100)%는\n            Vault에 보너스 reward로 지급하고, 나머지는 Reinvest한다.\n     */\n    function accrue() public payable override onlyDelegator {\n        require(msg.value > 0, 'accrue: You should send staking reward as EVMOS.');\n\n        // 1. distribute to Protocol\n        uint256 reserved = (msg.value * reservedBps) / 1E4;\n        reservedPool += reserved; /// @TODO reward state 관리가 아닌 매출 관련 deposit contract 로 send 되도록 수정해야 함\n\n        uint256 distributable = msg.value - reserved;\n\n        uint256 sumOfInterests;\n        uint256[] memory interestFor;\n\n        (sumOfInterests, interestFor) = _calculateInterestForVaults();\n\n        if (sumOfInterests == 0) {\n            // no or tiny debt\n            totalAmount += distributable;\n            emit Accrue(msg.sender, distributable, totalAmount);\n            return;\n        }\n\n        // 2-(1): reward to repay interest for vaults is insufficient.\n        if (sumOfInterests >= distributable) {\n            for (uint256 i = 0; i < vaults.length; i++) {\n                IVault vault = IVault(vaults[i]);\n                uint256 interestInBase = (interestFor[i] * distributable) / sumOfInterests;\n                uint256 minPaidInterest = vault.getTokenOut(interestInBase);\n                vault.payInterest{value: interestInBase}(minPaidInterest);\n            }\n\n            emit Accrue(msg.sender, 0, totalAmount);\n        }\n        // 2-(2): reward to repay interest for vaults is sufficient.\n        else {\n            uint256 distributed = reserved;\n\n            // Vault 에 추가적으로 지급하는 Staking Reward (상황에 따라 추가 Incentive 가 없을 수 있음 % 로 조절함)\n            uint256 additonalRewardForVaults = ((distributable - sumOfInterests) * vaultRewardBps) / 1E4;\n            for (uint256 i = 0; i < vaults.length; i++) {\n                    \n                uint256 interestWithReward = interestFor[i] + ((additonalRewardForVaults * interestFor[i]) / sumOfInterests);\n                // value: accumulated interest + bonus reward\n                IVault(vaults[i]).payInterest{value: interestWithReward}(IVault(vaults[i]).accInterest());\n                distributed += interestWithReward;\n            }\n            \n            uint256 accrued = msg.value - distributed;\n\n            if (accrued > 0) {\n                totalAmount += accrued;\n                SafeToken.safeTransferEVMOS(msg.sender, accrued);\n            }\n\n            emit Accrue(msg.sender, accrued, totalAmount);\n        }\n    }\n\n\n    /***********************\n     * Private Functions *\n     ************************/\n\n    function _calculateInterestForVaults()\n        private\n        view\n        returns (uint256 _sumOfInterests, uint256[] memory interestFor)\n    {\n        _sumOfInterests = 0;\n        interestFor = new uint256[](vaults.length);\n        for (uint256 i = 0; i < vaults.length; i++) {\n            interestFor[i] = IVault(vaults[i]).getInterestInBase();\n            _sumOfInterests += interestFor[i];\n        }\n    }\n\n\n    function _stake(Position storage p, uint256 amount)\n        private\n        returns (uint256 share)\n    {\n        share = amountToShare(amount);\n        p.share += share;\n        totalAmount += amount;\n        totalShare += share;\n        // send EVMOS to delegator\n        SafeToken.safeTransferEVMOS(delegator, amount);\n\n        emit Stake(delegator, p.user, amount, share);\n    }\n\n    /**\n     @param p           Position\n     @param vault       owed by the user\n     @param amount      unstaked amount\n     @param repaidDebt  repaid amount in token\n     @param fee         unstake fee for force liquidation(kill)\n\n     @notice Unstake할 때, 가격변동 + 대출이자로 인해 빚이 늘어나는 것에 대비하여 자기자본도 일부 unstake 해야 한다.\n     */\n    function _unstake(\n        Position storage p,\n        address vault,\n        uint256 amount,\n        uint256 repaidDebt,\n        uint256 fee\n    ) private {\n\n        uint256 share = amountToShare(amount);\n\n        p.share -= share;\n        totalAmount -= amount;\n        totalShare -= share;\n\n        uint256 pendingDebtShare = repaidDebt > 0\n            ? IVault(vault).pendRepay(p.user, repaidDebt)\n            : 0;\n\n        uEVMOS.mintLockedToken(p.user, vault, amount - fee, pendingDebtShare);\n\n        if (fee > 0) {\n            /// @TODO 포지션 청산에 대한 performance fee 도 매출인데 매출을 따로 관리할 컨트랙트가 필요함\n            uEVMOS.mintLockedToken(address(this), vault, fee, 0);\n        }\n\n        emit Unstake(delegator, p.user, amount, share);\n    }\n\n    function _isHealthy(\n        address vault,\n        uint256 share,\n        uint256 debt\n    ) private view returns (bool healthy, uint256 debtInBase) {\n        debtInBase = IVault(vault).getBaseIn(debt);\n        healthy = debtInBase * 1e4 < shareToAmount(share) * killFactorBps;\n    }\n\n     function _adjustChangePositionArgs(\n        int256 equityInBaseChanged,\n        int256 debtInBaseChanged\n    )\n        private\n        pure\n        returns (\n            bool isStaking,\n            uint256 equity,\n            uint256 debtInBase,\n            int256 repaidDebtChanged\n        )\n    {\n        // kor) 논의 필요\n        require(\n            equityInBaseChanged * debtInBaseChanged >= 0,\n            'equityInBaseChanged * debtInBaseChanged < 0'\n        );\n\n        /**\n            @TODO\n            아래 if문은 equityInBaseChanged * debtInBaseChanged < 0 케이스 가능한 경우에 사용합니다. (아직 미완성)\n            바로 위 require문을 사용하게 되면\n            (equityInBaseChanged * debtInBaseChanged < 0인 케이스를 허용하지 않게 되면),\n            아래 if문은 삭제하고 else문 내 로직만 사용하면 됩니다. 또한 그 경우에는 repaidDebtChanged값도 고려하지 않아도 됩니다.\n            그런 경우라면, 이 _adjustChangePositionArgs 함수 전체를 changePosition 함수에 넣는 게 좋을 것 같습니다.\n         */\n        if (equityInBaseChanged * debtInBaseChanged < 0) {\n            // current, unreachable\n            bool isAddingEquity = equityInBaseChanged > 0;\n            equity = uint256(abs(equityInBaseChanged));\n            debtInBase = uint256(abs(debtInBaseChanged));\n\n            (isStaking, equity, debtInBase, repaidDebtChanged) = equity >\n                debtInBase\n                ? (\n                    isAddingEquity,\n                    equity - debtInBase,\n                    uint256(0),\n                    isAddingEquity ? int256(debtInBase) : -int256(debtInBase)\n                )\n                : (\n                    !isAddingEquity,\n                    uint256(0),\n                    debtInBase - equity,\n                    isAddingEquity ? int256(equity) : -int256(equity)\n                );\n        } else {\n            equity = uint256(abs(equityInBaseChanged));\n            debtInBase = uint256(abs(debtInBaseChanged));\n            isStaking = (equityInBaseChanged > 0 || debtInBaseChanged > 0);\n        }\n    }\n\n    /******************\n     * Util Functions *\n     *******************/\n    /// @notice 유저는 예치하는 시점에 (예치 금액 / totalAmount) * totalShare 에 해당하는 share를 받음.\n    function amountToShare(uint256 amount)\n        public\n        view\n        returns (uint256)\n    {\n        return (totalAmount == 0) ? amount : (totalShare * amount) / totalAmount;\n    }\n\n    function shareToAmount(uint256 share) public view returns (uint256) {\n        return (totalShare == 0) ? share : (totalAmount * share) / totalShare;\n    }\n\n    function abs(int256 x) private pure returns (int256) {\n        return x >= 0 ? x : -x;\n    }\n\n    // TODO 매출 클레임 처리를 다른 컨트랙트에 하는게 어떨지?\n    function claimReserves(address token, uint256 amount) external onlyOwner {\n        if (token == address(0)) {\n            SafeToken.safeTransferEVMOS(owner(), amount);\n        } else {\n            SafeToken.safeTransfer(token, owner(), amount);\n        }\n    }\n\n    /// @dev Fallback function to accept EVMOS.\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "contracts/interface/IStayking.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.17;\n\n/************************************************************\n * @dev Glossary\n *      debt : debtAmount in borrowing token (e.g. USDC and OSMO, ATOM)\n *      debtInBase: debtAmount in EVMOS(Base Token)\n *************************************************************/\ninterface IStayking {\n    function updateVault(address token, address vault) external;\n\n    function tokenToVault(address token) external view returns (address vault);\n\n    function changeDelegator(address delegator) external;\n\n    function changeUnbondedEvmos(address _uevmos) external;\n\n    // function setWhitelistDelegatorStatus(address delegator, bool status) external;\n\n    /// @dev min debtAmount in EVMOS (base token)\n    function minDebtInBase() external view returns (uint256);\n\n    function reservedBps() external view returns (uint256);\n\n    function vaultRewardBps() external view returns (uint256);\n\n    function totalAmount() external view returns (uint256);\n\n    function totalShare() external view returns (uint256);\n\n    function killFactorBps() external view returns (uint256);\n\n    function liquidateDebtFactorBps() external view returns (uint256);\n\n    function liquidationFeeBps() external view returns (uint256);\n\n    function debtAmountOf(address user, address vault)\n        external\n        view\n        returns (uint256 debt);\n\n    /// @param debtToken    debtToken Address (not vault address)\n    /// @param equity       equityAmount in EVMOS\n    /// @param debtInBase   debtAmount in EVMOS\n    function addPosition(\n        address debtToken,\n        uint256 equity,\n        uint256 debtInBase\n    ) external payable;\n\n    /// @param debtToken    debtToken Address (not vault address)\n    function removePosition(address debtToken) external;\n\n    function getPositionInfo(address user, address vault)\n        external\n        view\n        returns (\n            uint256 equityInBase,\n            uint256 debtInBase,\n            uint256 debt,\n            uint256 positionId\n        );\n\n    function isKillable(address debtToken, uint256 positionId)\n        external\n        view\n        returns (bool);\n\n    function kill(address debtToken, uint256 positionId) external;\n\n    /***********************\n     * Only for Delegator *\n     ***********************/\n    // function getAccruedValue(uint256 reward) external view returns (uint256);\n\n    function accrue() external payable;\n}"
    },
    "contracts/interface/IVault.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\ninterface IVault {\n    function token() external returns (address);\n\n    function stayking() external returns (address);\n\n    function interestModel() external returns (address);\n\n    function totalAmount() external view returns (uint256);\n\n    function debtAmountOf(address user) external view returns (uint256);\n\n    function debtAmountInBase(address user) external view returns (uint256);\n\n    function totalStakedDebtAmount() external view returns (uint256);\n\n    function totalDebtAmount() external view returns (uint256);\n\n    function totalPendingDebtAmount() external view returns (uint256);\n\n    function totalPendingDebtShare() external view returns (uint256);\n\n    function accInterest() external view returns (uint256);\n\n    function minReservedBps() external view returns (uint256);\n\n    function lastAccruedAt() external view returns (uint256);\n\n    function utilizationRateBps() external view returns (uint256);\n\n    /// @dev denominator = 1E18\n    function getInterestRate() external view returns (uint256);\n\n    function deposit(uint256 amount) external returns (uint256 share);\n\n    function withdraw(uint256 share) external returns (uint256 amount);\n\n    function getPendingDebt(address user) external view returns (uint256 debt);\n\n    function getPendingDebtInBase(address user)\n        external\n        view\n        returns (uint256 debtInBase);\n\n    function getBaseIn(uint256 tokenOut) external view returns (uint256 baseIn);\n\n    function getBaseOut(uint256 tokenIn)\n        external\n        view\n        returns (uint256 baseOut);\n\n    function getTokenIn(uint256 baseOut)\n        external\n        view\n        returns (uint256 tokenIn);\n\n    function getTokenOut(uint256 baseIn)\n        external\n        view\n        returns (uint256 tokenOut);\n\n    function pendingDebtAmountToShare(uint256 amount)\n        external\n        view\n        returns (uint256);\n\n    function pendingDebtShareToAmount(uint256 share)\n        external\n        view\n        returns (uint256);\n\n    /******************************\n     * Only for Stayking Contract *\n     ******************************/\n    function loan(address user, uint256 debtInBase)\n        external\n        returns (uint256 debt);\n\n    function repayInToken(address user, uint256 debt) external;\n\n    function repayInBase(address user, uint256 minRepaid)\n        external\n        payable\n        returns (uint256 repaid);\n\n    function takeDebtOwnership(address from, uint256 amount) external;\n\n    function getInterestInBase() external view returns (uint256);\n\n    function payInterest(uint256 minPaidInterest) external payable;\n\n    function pendRepay(address user, uint256 amount)\n        external\n        returns (uint256 pendingDebtShare);\n\n    function repayPendingDebt(address user) external payable returns (uint256);\n\n    function updateInterestModel(address newInterestModel) external;\n\n    function updateSwapHelper(address newSwapHelper) external;\n\n    function updateMinReservedBps(uint256 newMinReservedBps) external;\n}"
    },
    "contracts/interface/ISwapHelper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\n/************************************************************\n * @dev\n * Glossary\n * X : Input Token\n * Y : Output Token\n * Dx : Amount of Input Token\n * Dy : Amount of Output Token\n *************************************************************/\ninterface ISwapHelper {\n    function getDy(\n        address tokenX,\n        address tokenY,\n        uint256 dx\n    ) external view returns (uint256 dy);\n\n    function getDx(\n        address tokenX,\n        address tokenY,\n        uint256 dy\n    ) external view returns (uint256 dx);\n\n    function exchange(\n        address tokenX,\n        address tokenY,\n        uint256 dx,\n        uint256 minDy\n    ) external payable returns (uint256 dy);\n}\n"
    },
    "contracts/interface/IUnbondedEvmos.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\ninterface IUnbondedEvmos {\n    function lastUnbondedAt() external view returns (uint256);\n\n    function unbondingInterval() external view returns (uint256);\n\n    function mintLockedToken(\n        address to,\n        address vault,\n        uint256 amount,\n        uint256 debtShare\n    ) external;\n\n    function unlock() external;\n\n    function supplyUnbondedToken() external payable;\n\n    function isMinter(address account) external view returns (bool);\n\n    function updateMinterStatus(address account, bool status) external;\n\n    function getUnlockable(address account)\n        external\n        view\n        returns (uint256 unlockable, uint256 debt);\n\n    function isKillable(uint256 lockedId) external returns (bool);\n\n    function kill(uint256 lockedId) external;\n}\n"
    },
    "contracts/lib/utils/SafeToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.3;\n\nlibrary SafeToken {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x095ea7b3, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            '!safeApprove'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0xa9059cbb, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            '!safeTransfer'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(0x23b872dd, from, to, value)\n        );\n\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            '!safeTransferFrom'\n        );\n    }\n\n    function safeTransferEVMOS(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, '!safeTransferEVMOS');\n    }\n}\n"
    },
    "contracts/lib/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\npragma solidity ^0.8.9;\n\nimport './ContextUpgradeable.sol';\nimport './Initializable.sol';\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), 'Ownable: caller is not the owner');\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            'Ownable: new owner is the zero address'\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/lib/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\npragma solidity ^0.8.9;\nimport './Initializable.sol';\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, 'ReentrancyGuard: reentrant call');\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/lib/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\npragma solidity ^0.8.9;\n\nimport './Initializable.sol';\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {}\n\n    function __Context_init_unchained() internal onlyInitializing {}\n\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/lib/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\npragma solidity ^0.8.9;\n\nimport './AddressUpgradeable.sol';\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) ||\n                (!AddressUpgradeable.isContract(address(this)) &&\n                    _initialized == 1),\n            'Initializable: contract is already initialized'\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(\n            !_initializing && _initialized < version,\n            'Initializable: contract is already initialized'\n        );\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, 'Initializable: contract is not initializing');\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, 'Initializable: contract is initializing');\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "contracts/lib/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\npragma solidity ^0.8.9;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            'Address: insufficient balance'\n        );\n\n        (bool success, ) = recipient.call{value: amount}('');\n        require(\n            success,\n            'Address: unable to send value, recipient may have reverted'\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, 'Address: low-level call failed');\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                'Address: low-level call with value failed'\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            'Address: insufficient balance for call'\n        );\n        require(isContract(target), 'Address: call to non-contract');\n\n        (bool success, bytes memory returndata) = target.call{value: value}(\n            data\n        );\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                'Address: low-level static call failed'\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), 'Address: static call to non-contract');\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/mock/MockSwapHelper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport 'hardhat/console.sol';\nimport '../interface/ISwapHelper.sol';\nimport './MockSwap.sol';\n\ncontract MockSwapHelper is ISwapHelper {\n    MockSwap public swap;\n\n    constructor(address payable swap_) {\n        swap = MockSwap(swap_);\n    }\n\n    function getDy(\n        address tokenX,\n        address tokenY,\n        uint256 dx\n    ) public view override returns (uint256 dy) {\n        return swap.getDy(tokenX, tokenY, dx);\n    }\n\n    function getDx(\n        address tokenX,\n        address tokenY,\n        uint256 dy\n    ) public view override returns (uint256 dx) {\n        return swap.getDx(tokenX, tokenY, dy);\n    }\n\n    function exchange(\n        address tokenX,\n        address tokenY,\n        uint256 dx,\n        uint256 minDy\n    ) public payable override returns (uint256 dy) {\n        if (tokenX == address(0)) {\n            require(msg.value == dx, 'MockSwap: msg.value != dx');\n            dy = swap.exchange{value: dx}(tokenX, tokenY, dx, minDy);\n        } else {\n            SafeToken.safeTransferFrom(tokenX, msg.sender, address(this), dx);\n            SafeToken.safeApprove(tokenX, address(swap), dx);\n            dy = swap.exchange(tokenX, tokenY, dx, minDy);\n        }\n\n        if (tokenY == address(0)) {\n            SafeToken.safeTransferEVMOS(msg.sender, dy);\n        } else {\n            SafeToken.safeTransfer(tokenY, msg.sender, dy);\n        }\n    }\n\n    fallback() external payable {}\n\n    receive() external payable {}\n}\n"
    },
    "contracts/mock/MockSwap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.4;\n\nimport 'hardhat/console.sol';\nimport '../lib/interface/IERC20.sol';\nimport '../lib/utils/SafeToken.sol';\nimport '../lib/Ownable.sol';\n\ncontract MockSwap is Ownable {\n    /**\n        @dev 본 컨트랙트는 로컬 노드 배포용 컨트랙트로,\n        EvmoSwapRouter과 유사한 역할을 하는 DEX라고 생각하면 됩니다.\n\n        native token(EVMOS)과 나머지 모든 토큰의 교환비는 임의로 1: 2라고 놓았습니다.\n        (EVMOS의 가치 = 다른 토큰의 가치 * 2)\n\n        TODO 배포 후 본 컨트랙트로 유동성 추가해 주어야 함.\n        ex) IERC20(tokenAddress).mint(address(this), MAX_UINT / 2);\n     */\n\n    mapping(address => bool) public isSupported;\n    uint256 public EVMOSpriceBps;\n\n    constructor(address[] memory tokens) {\n        for (uint256 i = 0; i < tokens.length; i++) {\n            isSupported[tokens[i]] = true;\n        }\n\n        EVMOSpriceBps = 20000;\n    }\n\n    function getDx(\n        address tokenX,\n        address tokenY,\n        uint256 dy\n    ) public view returns (uint256) {\n        if (tokenX == address(0)) return (dy * 1E4) / EVMOSpriceBps;\n        else if (tokenY == address(0)) return (dy * EVMOSpriceBps) / 1E4;\n        else return dy;\n    }\n\n    function getDy(\n        address tokenX,\n        address tokenY,\n        uint256 dx\n    ) public view returns (uint256) {\n        if (tokenX == address(0)) return (dx * EVMOSpriceBps) / 1E4;\n        else if (tokenY == address(0)) return (dx * 1E4) / EVMOSpriceBps;\n        else return dx;\n    }\n\n    function exchange(\n        address tokenX,\n        address tokenY,\n        uint256 dx,\n        uint256 /* minDy */\n    ) public payable returns (uint256 dy) {\n        console.log(tokenX, tokenY, dx);\n        if (tokenX == address(0)) {\n            require(msg.value == dx, 'MockSwap: msg.value != dx');\n        } else {\n            SafeToken.safeTransferFrom(tokenX, msg.sender, address(this), dx);\n        }\n\n        dy = getDy(tokenX, tokenY, dx);\n        console.log(tokenY, msg.sender, dy);\n        if (tokenY == address(0)) {\n            SafeToken.safeTransferEVMOS(msg.sender, dy);\n        } else {\n            SafeToken.safeTransfer(tokenY, msg.sender, dy);\n        }\n    }\n\n    // sweep in-contract EVMOS\n    function sweep() public onlyOwner {\n        SafeToken.safeTransferEVMOS(msg.sender, address(this).balance);\n    }\n\n    function changeRatio(uint256 newRatio) public onlyOwner {\n        require(newRatio > 0, 'newRatio <= 0');\n        EVMOSpriceBps = newRatio;\n    }\n\n    fallback() external payable {}\n\n    /// @dev Fallback function to accept EVMOS.\n    receive() external payable {}\n}\n"
    },
    "contracts/lib/interface/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/lib/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\npragma solidity ^0.8.9;\n\nimport './Context.sol';\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), 'Ownable: caller is not the owner');\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            'Ownable: new owner is the zero address'\n        );\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/lib/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\npragma solidity ^0.8.9;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/lib/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\npragma solidity ^0.8.9;\n\nimport './interface/IERC20.sol';\nimport './Context.sol';\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(\n            currentAllowance >= subtractedValue,\n            'ERC20: decreased allowance below zero'\n        );\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), 'ERC20: transfer from the zero address');\n        require(to != address(0), 'ERC20: transfer to the zero address');\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(\n            fromBalance >= amount,\n            'ERC20: transfer amount exceeds balance'\n        );\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: mint to the zero address');\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: burn from the zero address');\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), 'ERC20: approve from the zero address');\n        require(spender != address(0), 'ERC20: approve to the zero address');\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance >= amount,\n                'ERC20: insufficient allowance'\n            );\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/lib/ERC20Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\npragma solidity ^0.8.9;\n\nimport './ERC20.sol';\nimport './Ownable.sol';\n\ncontract ERC20Ownable is ERC20, Ownable {\n    constructor(string memory name_, string memory symbol_)\n        ERC20(name_, symbol_)\n    {}\n\n    function mint(address account, uint256 amount) public onlyOwner {\n        _mint(account, amount);\n    }\n}\n"
    },
    "contracts/lib/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\npragma solidity ^0.8.9;\n\nimport './interface/IERC20.sol';\nimport './ContextUpgradeable.sol';\nimport './Initializable.sol';\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20 {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_)\n        internal\n        onlyInitializing\n    {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(\n            currentAllowance >= subtractedValue,\n            'ERC20: decreased allowance below zero'\n        );\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), 'ERC20: transfer from the zero address');\n        require(to != address(0), 'ERC20: transfer to the zero address');\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(\n            fromBalance >= amount,\n            'ERC20: transfer amount exceeds balance'\n        );\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: mint to the zero address');\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), 'ERC20: burn from the zero address');\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, 'ERC20: burn amount exceeds balance');\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), 'ERC20: approve from the zero address');\n        require(spender != address(0), 'ERC20: approve to the zero address');\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(\n                currentAllowance >= amount,\n                'ERC20: insufficient allowance'\n            );\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/Vault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport 'hardhat/console.sol';\nimport './interface/IVault.sol';\nimport './interface/IInterestModel.sol';\nimport './interface/ISwapHelper.sol';\nimport './interface/IStayking.sol';\nimport './lib/ERC20Upgradeable.sol';\nimport './lib/OwnableUpgradeable.sol';\nimport './lib/interface/IERC20.sol';\nimport './lib/utils/SafeToken.sol';\n\n/************************************************************\n * @dev Glossary\n * amount vs share\n * amount => unit of baseToken\n * share => unit of ibToken\n *************************************************************/\ncontract Vault is IVault, ERC20Upgradeable, OwnableUpgradeable {\n\n    address private constant BASE_TOKEN = address(0);\n    uint256 private constant DENOM = 1E18;\n\n    event Deposit(address user, uint256 amount, uint256 share);\n    event Withdraw(address user, uint256 amount, uint256 share);\n    event Loan(address user, uint256 debtAmount);\n    event Repay(address user, uint256 debtAmount);\n    event PayInterest(uint256 paidInterest, uint256 remained, uint256 insufficient);\n    event TransferDebtOwnership(address from, address to, uint256 amount);\n    event UtilizationRate(uint256 rateBps);\n    event RepayPendingDebt(address user, uint256 amount, uint256 pendingDebt, uint256 pendingDebtInBase, uint256 remained);\n\n    ISwapHelper public swapHelper;\n\n    address public override token;\n    address public override stayking;\n    address public override interestModel;\n\n    /** @dev\n    totalAmount == Token.balanceOf(this) + totalStakedDebtAmount + totalPendingDebtAmount\n    totalShare == totalSupply()\n    */\n\n    // Debt Amounts\n    mapping(address => uint256) public override debtAmountOf;\n    uint256 public override totalStakedDebtAmount;\n\n    // Pending Debts\n    mapping(address => uint256) public pendingDebtShareOf;\n    uint256 public override totalPendingDebtShare;\n    uint256 public override totalPendingDebtAmount;\n\n    uint256 public override minReservedBps;\n    uint256 public override lastAccruedAt;\n    uint256 public override accInterest;\n\n    // information of last paid interest amount & time\n    // these 5 values change every day when interest is paid.\n    // APR = 365 * lastReward / lastTotalAmount;\n    struct LastPaid {\n        uint256 totalDebtAmount;\n        uint256 totalAmount;\n        uint256 reward;\n        uint128 timestamp;\n        uint128 interval;\n    }\n    LastPaid public lastPaid;\n\n    /*************\n     * Modifiers *\n     **************/\n\n    modifier onlyStayking() {\n        require(msg.sender == stayking, 'Vault: Not Stayking contract.');\n        _;\n    }\n\n    modifier accrueBefore() {\n        _accrue();\n        _;\n    }\n\n    /****************\n     * Initializer *\n     *****************/\n\n    function __Vault_init(\n        string calldata _name,\n        string calldata _symbol,\n        address _swapHelper,\n        address _stayking,\n        address _token,\n        address _interestModel,\n        uint256 _minReservedBps\n    ) external initializer {\n        // require(_stayking != address(0), 'Vault: Stayking address is zero');\n        require(_token != address(0), 'Vault: Base Token is zero address');\n\n        __ERC20_init(_name, _symbol);\n        __Ownable_init();\n\n        token = _token;\n        stayking = _stayking;\n        lastAccruedAt = block.timestamp;\n        updateMinReservedBps(_minReservedBps);\n        updateInterestModel(_interestModel);\n        updateSwapHelper(_swapHelper);\n\n        lastPaid = LastPaid({\n            totalDebtAmount: 0,\n            totalAmount: 0,\n            reward: 0,\n            timestamp: uint128(block.timestamp),\n            interval: uint128(0)\n        });\n    }\n\n    function getAccruedRateBps()\n        public\n        view\n        returns (uint256 baseBps, uint256 bonusBps)\n    {\n        uint256 amount = totalAmount();\n        \n        if (amount == 0) {\n            return (0, 0);\n        }\n\n        baseBps =\n            (1E4 * getInterestRate() * totalDebtAmount() * 365 days) /\n            amount /\n            1E18;\n\n        bonusBps =\n            IStayking(stayking).totalAmount() == 0 ? 0 : (getBaseIn(totalStakedDebtAmount) *\n                IStayking(stayking).vaultRewardBps()) /\n            IStayking(stayking).totalAmount();\n    }\n\n    // @dev (token in vault) + (debt)\n    function totalDebtAmount() public view override returns (uint256) {\n        return totalStakedDebtAmount + totalPendingDebtAmount;\n    }\n\n    function totalAmount() public view override returns (uint256) {\n        return IERC20(token).balanceOf(address(this)) + totalDebtAmount();\n    }\n\n    function updateMinReservedBps(uint256 _minReservedBps)\n        public\n        override\n        onlyOwner\n    {\n        minReservedBps = _minReservedBps;\n    }\n\n    function updateInterestModel(address _interestModel)\n        public\n        override\n        onlyOwner\n    {\n        interestModel = _interestModel;\n    }\n\n    function updateSwapHelper(address _swapHelper) public override onlyOwner {\n        swapHelper = ISwapHelper(_swapHelper);\n    }\n\n    function amountToShare(uint256 amount) public view returns (uint256) {\n        uint256 _totalAmount = totalAmount();\n        return\n            (_totalAmount == 0)\n                ? amount\n                : (totalSupply() * amount) / _totalAmount;\n    }\n\n    function shareToAmount(uint256 share) public view returns (uint256) {\n        uint256 totalShare = totalSupply();\n        return (totalShare == 0) ? share : (totalAmount() * share) / totalShare;\n    }\n\n    function debtAmountInBase(address user)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return getBaseIn(debtAmountOf[user]);\n    }\n\n    function pendingDebtAmountToShare(uint256 amount)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return\n            (totalPendingDebtAmount == 0)\n                ? amount\n                : (totalPendingDebtShare * amount) / totalPendingDebtAmount;\n    }\n\n    function pendingDebtShareToAmount(uint256 share)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return\n            (totalPendingDebtShare == 0)\n                ? share\n                : (totalPendingDebtAmount * share) / totalPendingDebtShare;\n    }\n\n    /// @notice Amount of interest paid per second\n    /// @dev denominator = 1E18\n    function getInterestRate()\n        public\n        view\n        override\n        returns (uint256 interestRate)\n    {\n        interestRate = IInterestModel(interestModel).calcInterestRate(\n            totalDebtAmount(),\n            IERC20(token).balanceOf(address(this))\n        );\n    }\n\n    function utilizationRateBps() public view override returns (uint256) {\n        uint256 amount = totalAmount();\n        if (amount == 0) return 0;\n\n        return (1E4 * totalDebtAmount()) / amount;\n    }\n\n    /**\n        @dev\n        Before each time the position is changed,\n        the interest on \"Stayking debt\" (not on \"pending debt\")\n        during (lastAccruedAt ~ present) is calculated and added.\n     */\n    function _accrue() private {\n        if (block.timestamp <= lastAccruedAt) return;\n        uint256 timePast = block.timestamp - lastAccruedAt;\n\n        uint256 stakedInterest = (getInterestRate() *\n            totalStakedDebtAmount *\n            timePast) / DENOM;\n\n        accInterest += stakedInterest;\n\n        uint256 pendingInterest = (getInterestRate() *\n            totalPendingDebtAmount *\n            timePast) / DENOM;\n        totalPendingDebtAmount += pendingInterest;\n\n        lastAccruedAt = block.timestamp;\n    }\n\n    /// @dev for test -> should be REMOVED\n    function accrue() public {\n        _accrue();\n    }\n\n    /******************\n     * Swap Functions *\n     *******************/\n    /**\n     @dev\n     baseAmount: amount of EVMOS\n     tokenAmount: amount of vault token (e.g. ATOM, USDC, ...etc)\n     */\n\n    /// @dev vault token -> baseToken(EVMOS) (known baseAmount)\n    function _swapToBase(uint256 baseAmount)\n        private\n        returns (uint256 tokenAmount)\n    {\n        // 1. calculate amountIn\n        tokenAmount = getTokenIn(baseAmount);\n        // 2. approve to swapHelper\n        SafeToken.safeApprove(token, address(swapHelper), tokenAmount);\n        // 3. swap\n        swapHelper.exchange(token, BASE_TOKEN, tokenAmount, baseAmount);\n    }\n\n    /// @dev baseToken(EVMOS) -> vault token (known baseAmount)\n    function _swapFromBase(uint256 baseAmount, uint256 minDy)\n        private\n        returns (uint256 tokenAmount)\n    {\n        return\n            swapHelper.exchange{value: baseAmount}(\n                BASE_TOKEN,\n                token,\n                baseAmount,\n                minDy\n            );\n    }\n\n    /**\n     @notice swapHelper calc functions\n     function naming: get[ target of token ][ direction ]\n      * target:     Base(EVMOS)  / Token\n      * direction:  In(=getDx) / Out(=getDy)\n\n      e.g. function getBaseIn()\n      -> this func calculates how much EVMOS is needed to swap EVMOS to Token.\n     */\n\n    /// @dev calc (?)EVMOS = $ token\n    function getBaseIn(uint256 tokenOut)\n        public\n        view\n        override\n        returns (uint256 baseIn)\n    {\n        return swapHelper.getDx(BASE_TOKEN, token, tokenOut);\n    }\n\n    /// @dev calc $ token = (?)EVMOS\n    function getBaseOut(uint256 baseIn)\n        public\n        view\n        override\n        returns (uint256 tokenOut)\n    {\n        return swapHelper.getDy(token, BASE_TOKEN, baseIn);\n    }\n\n    /// @dev calc (?)token = $ EVMOS\n    function getTokenIn(uint256 baseOut)\n        public\n        view\n        override\n        returns (uint256 tokenIn)\n    {\n        return swapHelper.getDx(token, BASE_TOKEN, baseOut);\n    }\n\n    /// @dev calc $ EVMOS = (?)token\n    function getTokenOut(uint256 tokenIn)\n        public\n        view\n        override\n        returns (uint256 baseOut)\n    {\n        return swapHelper.getDy(BASE_TOKEN, token, tokenIn);\n    }\n\n    /************************************\n     * interface IVault Implementations\n     ************************************/\n\n    /// @notice user approve should be preceded\n    function deposit(uint256 amount)\n        public\n        override\n        accrueBefore\n        returns (uint256 share)\n    {\n        share = amountToShare(amount);\n        SafeToken.safeTransferFrom(token, msg.sender, address(this), amount);\n        _mint(msg.sender, share);\n\n        emit Deposit(msg.sender, amount, share);\n    }\n\n    function withdraw(uint256 share)\n        public\n        override\n        accrueBefore\n        returns (uint256 amount)\n    {\n        amount = shareToAmount(share);\n        // TODO minReserved?\n        _burn(msg.sender, share);\n        SafeToken.safeTransfer(token, msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount, share);\n    }\n\n    /// @notice loan is only for Stayking contract.\n    function loan(address user, uint256 debtInBase)\n        public\n        override\n        onlyStayking\n        accrueBefore\n        returns (uint256 debt)\n    {\n        require(user != address(0), 'loan: zero address cannot loan.');\n\n        ///@dev swap token -> (amountInBase)EVMOS\n        debt = _swapToBase(debtInBase);\n        debtAmountOf[user] += debt;\n        totalStakedDebtAmount += debt;\n        require(\n            (totalStakedDebtAmount + totalPendingDebtAmount) * 1E4 <=\n                totalAmount() * (1E4 - minReservedBps),\n            \"Loan: Cant' loan debt anymore.\"\n        );\n        SafeToken.safeTransferEVMOS(msg.sender, debtInBase);\n        emit Loan(user, debt);\n    }\n\n    // @TODO Should approve MAX_UINT?\n    /// @dev Repay user's debt.\n    /// Stayking should approve token first.\n    function _repay(address user, uint256 amount) private accrueBefore {\n        require(\n            debtAmountOf[user] >= amount,\n            'repay: too much amount to repay.'\n        );\n        unchecked {\n            debtAmountOf[user] -= amount;\n        }\n        totalStakedDebtAmount -= amount;\n        emit Repay(user, amount);\n    }\n\n    function repayInToken(address user, uint256 amount)\n        public\n        override\n        onlyStayking\n    {\n        SafeToken.safeTransferFrom(token, user, address(this), amount);\n        _repay(user, amount);\n    }\n\n    /// @dev partial close 기능인데 일단 현재는 add equity/debt 만 가능한 구조이므로 deprecated 함\n    /// @dev repay debt for Base token(EVMOS).\n    /// @param user debt owner\n    /// @param minRepaid  minimum repaid debtToken amonut\n    function repayInBase(address user, uint256 minRepaid)\n        public\n        payable\n        override\n        onlyStayking\n        returns (uint256 repaid)\n    {\n        repaid = _swapFromBase(msg.value, minRepaid);\n        _repay(user, repaid);\n    }\n\n    function takeDebtOwnership(address from, uint256 amount)\n        public\n        override\n        onlyStayking\n    {\n        require(\n            debtAmountOf[from] >= amount,\n            'takeDebtOwnership: too much amount to take.'\n        );\n        unchecked {\n            debtAmountOf[from] -= amount;\n        }\n        debtAmountOf[msg.sender] += amount;\n        emit TransferDebtOwnership(from, msg.sender, amount);\n    }\n\n    /// @dev calculate interest (1 day) in base (EVMOS)\n    function getInterestInBase() public view override returns (uint256) {\n        return accInterest > 0 ? getBaseIn(accInterest) : 0;\n    }\n\n    // msg.value = interest + reward(bonus)\n    function payInterest(uint256 minPaidInterest)\n        public\n        payable\n        override\n        onlyStayking\n        accrueBefore\n    {\n        require(\n            block.timestamp > uint256(lastPaid.timestamp),\n            'payInterest: already paid.'\n        );\n        uint256 paidInterest = _swapFromBase(msg.value, minPaidInterest);\n\n        lastPaid.totalDebtAmount = totalDebtAmount();\n        lastPaid.totalAmount = totalAmount();\n        lastPaid.interval = uint128(block.timestamp) - lastPaid.timestamp;\n        lastPaid.timestamp = uint128(block.timestamp);\n        lastPaid.reward = paidInterest;\n\n        emit PayInterest(\n            paidInterest, \n            paidInterest > accInterest ? paidInterest - accInterest : 0, \n            accInterest > paidInterest ? accInterest - paidInterest : 0\n        );\n        // 부족하든 부족하지 않든 이자를 지급하고 축적된 Vault 의 accInterest 는 0 으로 초기화 하여 Epoch 마다 Reset 함\n        accInterest = 0;\n    }\n\n    /// @dev pending repay debt because of EVMOS Unstaking's 14 days lock.\n    /// Stayking should approve token first.\n    function pendRepay(address user, uint256 amount)\n        public\n        override\n        onlyStayking\n        returns (uint256 pendingDebtShare)\n    {\n        require(\n            amount <= debtAmountOf[user],\n            'pendRepay: too much amount to repay.'\n        );\n        /// @dev subtract from debtAmountOf[user]\n        unchecked {\n            debtAmountOf[user] -= amount;\n        }\n        totalStakedDebtAmount -= amount;\n\n        /// @dev The pendingDebtAmount increases over time.\n        /// This is because lending interest is charged during the 14 days of unbonding.\n        pendingDebtShare = pendingDebtAmountToShare(amount);\n        pendingDebtShareOf[user] += pendingDebtShare;\n\n        totalPendingDebtShare += pendingDebtShare;\n        totalPendingDebtAmount += amount;\n    }\n\n    function getPendingDebt(address user)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return pendingDebtShareToAmount(pendingDebtShareOf[user]);\n    }\n\n    function getPendingDebtInBase(address user)\n        public\n        view\n        override\n        returns (uint256)\n    {\n        return getBaseIn(getPendingDebt(user));\n    }\n\n    /// @dev stayking should send with msg.value(=repayingDebtInBase)\n    function repayPendingDebt(address user)\n        public\n        payable\n        override\n        returns (uint256 remained)\n    {\n        uint256 pendingDebt = getPendingDebt(user);\n        uint256 pendingDebtInBase = getBaseIn(pendingDebt);\n\n        if (msg.value > pendingDebtInBase) {\n            _swapFromBase(pendingDebtInBase, pendingDebt);\n            // return remained EVMOS\n            remained = msg.value - pendingDebtInBase;\n            SafeToken.safeTransferEVMOS(msg.sender, remained);\n        } else {\n            /**\n             * @dev unbonding 이후 빚보다 EVMOS 수량이 적을 때 share 에서 차감하는 방식이었는데\n             *      프로토콜에 손해가 있더라도 무조건 유저의 pending debt share 를 0 으로 초기화 하는 게 더 나음\n             *      청산 임계치 killFactor 를 조절하는 것이 더 나음 ( 현재 75 % )\n             **/\n            // uint256 repaidDebtAmount = _swapFromBase(msg.value, 1);\n            // uint256 repaidDebtShare = pendingDebtAmountToShare(repaidDebtAmount);\n            // pendingDebtShareOf[user] -= repaidDebtShare;\n            remained = 0;\n        }\n        pendingDebtShareOf[user] = 0;\n\n        emit RepayPendingDebt(user, msg.value, pendingDebt, pendingDebtInBase, remained);\n    }\n\n    /// @dev Fallback function to accept EVMOS.\n    receive() external payable {}\n\n    fallback() external payable {}\n}\n"
    },
    "contracts/interface/IInterestModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IInterestModel {\n    function calcInterestRate(uint256 debt, uint256 floating)\n        external\n        pure\n        returns (uint256);\n}"
    },
    "contracts/UnbondedEvmos.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\nimport 'hardhat/console.sol';\nimport './interface/IUnbondedEvmos.sol';\nimport './interface/IVault.sol';\nimport './lib/OwnableUpgradeable.sol';\nimport './lib/ERC20Upgradeable.sol';\nimport './lib/utils/SafeToken.sol';\n\ncontract UnbondedEvmos is IUnbondedEvmos, OwnableUpgradeable, ERC20Upgradeable {\n\n    event Lock(address account, address vault, uint256 lockedIndex);\n    event Unlock(address account, uint256 amount, uint256 returned);\n    event Supply(uint256 amount);\n    event Withdraw(address account, uint256 amount);\n    event UpdateMinterStatus(address account, bool status);\n    event UpdateConfigs(uint256 unbondingInterval);\n\n    mapping(address => bool) public override isMinter;\n\n    uint256 public override lastUnbondedAt;\n    // it depends on the parameter values of the governance in the protocol, testnet : 7 days, mainnet : 14days\n    uint256 public override unbondingInterval; \n\n    struct Locked {\n        bool received;\n        address account;\n        address vault;\n        uint256 amount;\n        uint256 debtShare;\n        uint256 unlockedAt;\n    }\n\n    Locked[] public locks;\n    uint256 public locksLength;\n\n    /** \n     * @dev\n     *  lockedIds: lock 된 EVMOS 자산 정보 locks 의 index 값 \n     *  nextUnlocked : 다음 search 할 index 값 \n     */\n    struct LockedQueue {\n        uint256 nextUnlocked;\n        uint256[] lockedIds;\n    }\n    mapping(address => LockedQueue) public lockedOf;\n    mapping(address => uint256) _balances;\n\n    /// @notice should set minter (maybe Stayking) after deployed\n    function __UnbondedEvmos_init(uint256 unbondingInterval_)\n        external\n        initializer\n    {\n        __Ownable_init();\n        __ERC20_init(\n            'Unstaked EVMOS', // name\n            'uEVMOS' //symbol\n        );\n        updateConfigs(unbondingInterval_);\n    }\n\n    /**************\n        Modifier\n     *************/\n    modifier onlyMinter() {\n        require(isMinter[msg.sender], 'uEVMOS: Not minter.');\n        _;\n    }\n\n    function updateMinterStatus(address account, bool status)\n        public\n        override\n        onlyOwner\n    {\n        isMinter[account] = status;\n        emit UpdateMinterStatus(account, status);\n    }\n\n    function updateConfigs(uint256 _unbondingInterval) public onlyOwner {\n        unbondingInterval = _unbondingInterval;\n        emit UpdateConfigs(_unbondingInterval);\n    }\n\n    /******************\n       Public Functions\n    *******************/\n    function transfer(address to, uint256 amount)\n        public\n        override\n        onlyMinter\n        returns (bool)\n    {\n        _transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public override onlyMinter returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev mint & lock uEVMOS from Stayking contarct removePosition, kill function execution.\n     **/\n    function mintLockedToken(\n        address to,\n        address vault,\n        uint256 amount,\n        uint256 debtShare\n    ) public override onlyMinter {\n        require(amount > 0, 'mintLockedToken: amount 0 is not allowed.');\n\n        LockedQueue storage lockedQueue = lockedOf[to];\n\n        /// @dev consume all of unlock queue\n        // _unlock(to, lockedQueue);\n\n        uint256 unlockedAt = _getUnlockedAt();\n\n        Locked memory locked = Locked({\n            account: to,\n            vault: vault,\n            amount: amount,\n            debtShare: debtShare,\n            unlockedAt: unlockedAt,\n            received: false\n        });\n\n        locks.push(locked);\n\n        uint256 newLockedId = locks.length - 1;\n        lockedQueue.lockedIds.push(newLockedId);\n\n        _mint(to, amount);\n\n        emit Lock(to, vault, newLockedId);\n    }\n\n    function unlock() public override {\n        LockedQueue storage lockedQueue = lockedOf[msg.sender];\n        uint256[] memory lockedIds = lockedQueue.lockedIds;\n        uint256 nextUnlocked = lockedQueue.nextUnlocked;\n\n        require(lockedIds.length > 0, \"user's locked asset is empty\");\n\n        uint256 unlockable;\n        uint256 returnable;\n        uint256 nextIdx = _getNextIdxOfLockedQueue(lockedIds, nextUnlocked);\n\n        for (; nextIdx < lockedIds.length; nextIdx++) {\n            Locked storage lock = locks[lockedIds[nextIdx]];\n\n            if (lock.unlockedAt <= block.timestamp && lock.received == false) {\n                /// @dev unlockable\n                unlockable += lock.amount;\n                /// @dev kor) (개선 필요) aggregate하여 repay 횟수 줄이기\n                uint256 returned = _repayPendingDebt(lock);\n                returnable += returned;\n            }\n        }\n\n        if (unlockable > 0) {\n            lockedQueue.nextUnlocked = nextIdx - 1;\n            \n            _burn(msg.sender, unlockable);\n\n            // 3. return EVMOS is returnable exists\n            if (returnable > 0) {\n                SafeToken.safeTransferEVMOS(msg.sender, returnable);\n            }\n            emit Unlock(msg.sender, unlockable, returnable);\n        }\n    }\n\n    function getLockedList(address account)\n        public\n        view\n        returns (Locked[] memory accountLocks)\n    {\n        LockedQueue memory lockedQueue = lockedOf[account];\n        uint256[] memory lockedIds = lockedQueue.lockedIds;\n\n        if (lockedIds.length == 0)\n            return new Locked[](0);\n\n        uint256 nextUnlocked = lockedQueue.nextUnlocked;\n        uint256 nextIdx = _getNextIdxOfLockedQueue(lockedIds, nextUnlocked);\n\n        accountLocks = new Locked[](lockedIds.length - nextIdx);\n\n        uint256 accountLocksIdx = 0;\n        for (uint256 i = nextIdx; i < lockedIds.length; i++) {\n            Locked memory locked = locks[lockedIds[i]];\n            accountLocks[accountLocksIdx++] = locked;\n        }\n\n        return accountLocks;\n    }\n\n    /// @dev calc user's unlockable uEVMOS(includes debt) & debt\n    function getUnlockable(address account)\n        public\n        view\n        override\n        returns (uint256 unlockable, uint256 debt)\n    {\n        uint256 nextUnlocked = lockedOf[account].nextUnlocked;\n        uint256[] memory lockedIds = lockedOf[account].lockedIds;\n\n        if (lockedIds.length == 0)\n            return (0, 0);\n        \n        uint256 nextIdx = _getNextIdxOfLockedQueue(lockedIds, nextUnlocked);\n        \n        for (uint256 i = nextIdx; i < lockedIds.length; i++) {\n            Locked memory lock = locks[lockedIds[i]];\n            if (lock.unlockedAt <= block.timestamp && lock.received == false) {\n                // unlockable amounts\n                unlockable += lock.amount;\n                debt += IVault(lock.vault).getPendingDebtInBase(account);\n            }\n        }\n    }\n\n\n    function supplyUnbondedToken() public payable override {\n        lastUnbondedAt = block.timestamp;\n        emit Supply(msg.value);\n    }\n\n    function getLockedOf(address account) public view returns (LockedQueue memory lockedQueue) {\n        lockedQueue = lockedOf[account];\n    }\n\n    /// @notice TODO\n    /// 유저가 일부만 unstake 요청하는 경우, 빚을 다 못 갚는 경우가 당연히 발생한다. 일단 부채비율이 100% 넘기는 경우 우리가 unlock 시키는 것만 구현.\n    function isKillable(uint256 lockedId) external view override returns (bool) {\n        Locked memory lock = locks[lockedId];\n        if (lock.unlockedAt > block.timestamp || lock.received == true) return false;\n        uint256 debt = IVault(lock.vault).getPendingDebtInBase(lock.account);\n        return debt >= lock.amount;\n    }\n\n    function kill(uint256 lockedId) public override {\n        Locked storage lock = locks[lockedId];\n        require(\n            lock.unlockedAt <= block.timestamp || lock.received == true,\n            'uEVMOS Kill: Cannot Unlock.'\n        );\n        uint256 debt = IVault(lock.vault).getPendingDebtInBase(lock.account);\n        uint256 lockedAmount = lock.amount;\n        // liquidate threshold: 100%\n        require(debt >= lockedAmount, 'uEVMOS Kill: Still safe.');\n\n        IVault(lock.vault).repayInBase{value: lockedAmount}(lock.account, 1);\n        lock.received = true;\n        /// @dev event Kill?\n    }\n\n    /******************\n       Private Functions\n    *******************/\n\n    function _repayPendingDebt(Locked storage lock) private returns (uint256 returnable) {\n        IVault vault = IVault(lock.vault);\n        address account = lock.account;\n        uint256 amount = lock.amount;\n\n        // Vault 의 repayPendingDebt 함수를 호출할 때 전체 unlockable 해진 유저의 EVMOS 를 보내 빚을 갚고 남은 EVMOS를 다시 uEVMOS 컨트랙트로 돌려줌\n        returnable = IVault(vault).repayPendingDebt{value: amount}(account);\n        lock.received = true;\n    }\n\n    function _getUnlockedAt() private view returns (uint256) {\n        return (lastUnbondedAt > block.timestamp ? lastUnbondedAt : block.timestamp) + unbondingInterval;\n    }\n\n    function _getNextIdxOfLockedQueue(uint256[] memory lockedIds, uint256 nextUnlocked) private pure returns (uint256) {\n        for (uint256 idx = lockedIds.length; idx > 0; idx--) {\n            if(lockedIds[idx - 1] < nextUnlocked) {\n                return idx;\n            }\n        }\n        return 0;\n    }\n\n    /******************\n       Ext functions\n    *******************/\n\n    function sweep() public onlyOwner {\n        SafeToken.safeTransferEVMOS(msg.sender, address(this).balance);\n    }\n\n    receive() external payable {}\n\n    fallback() external payable {}\n}"
    },
    "contracts/SwapHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\nimport './interface/ISwapHelper.sol';\nimport './interface/swap/v2-periphery/IUniswapV2Router.sol';\nimport './interface/swap/core/IUniswapV2Pair.sol';\nimport './lib/utils/SafeToken.sol';\n\ncontract SwapHelper is ISwapHelper {\n    IUniswapV2Router public router;\n\n    constructor(address _router) {\n        router = IUniswapV2Router(_router);\n    }\n\n    function getDy(\n        address tokenX,\n        address tokenY,\n        uint256 dx\n    ) public view override returns (uint256 dy) {\n        address[] memory path = new address[](2);\n        path[0] = tokenX == address(0) ? router.WETH() : tokenX;\n        path[1] = tokenY == address(0) ? router.WETH() : tokenY;\n\n        uint256[] memory amounts = router.getAmountsOut(dx, path);\n        return amounts[1];\n    }\n\n    function getDx(\n        address tokenX,\n        address tokenY,\n        uint256 dy\n    ) public view override returns (uint256 dx) {\n        address[] memory path = new address[](2);\n        path[0] = tokenX == address(0) ? router.WETH() : tokenX;\n        path[1] = tokenY == address(0) ? router.WETH() : tokenY;\n\n        uint256[] memory amounts = router.getAmountsIn(dy, path);\n        return amounts[0];\n    }\n\n    function exchange(\n        address tokenX,\n        address tokenY,\n        uint256 dx,\n        uint256 minDy\n    ) public payable override returns (uint256) {\n        address[] memory path = new address[](2);\n        uint256[] memory amounts;\n\n        // if tokenY == address(0) too, swapExactETHForTokens will be reverted.\n        if (tokenX == address(0)) {\n            require(dx == msg.value, 'exchange: invalid msg.value');\n\n            path[0] = router.WETH();\n            path[1] = tokenY;\n\n            amounts = router.swapExactETHForTokens{value: dx}(\n                minDy,\n                path,\n                msg.sender,\n                block.timestamp + 600 // 10 minutes, 수치는 조절해야 함\n            );\n\n            return amounts[1];\n        }\n        else {\n            /// @dev msg.sender should approve this helper contract first\n            SafeToken.safeTransferFrom(tokenX, msg.sender, address(this), dx);\n\n            SafeToken.safeApprove(tokenX, address(router), dx);\n\n            path[0] = tokenX;\n            path[1] = router.WETH();\n\n            amounts = router.swapExactTokensForETH(\n                dx,\n                minDy,\n                path,\n                msg.sender,\n                block.timestamp + 600 // 10 minutes, 수치는 조절해야 함\n            );\n\n            return amounts[1];\n        }\n    }\n\n    function getPriceImpactBpsFrom(\n        address _pair, \n        uint token0Amount,\n        uint token1Amount\n    ) \n        public \n        view \n        returns (uint priceImpactBps) \n    {\n        (uint reserve0, uint reserve1, uint32 blockTimestampLast) = IUniswapV2Pair(_pair).getReserves();\n        require(block.timestamp > blockTimestampLast, \"timestamp is error\");\n        require(reserve0 > 0 && reserve1 > 0, \"Insufficient Liquidity for the pair input\");\n\n        if(token1Amount == 0) {\n            token1Amount = router.quote(token0Amount, reserve0, reserve1);\n            priceImpactBps = ((reserve1 - token1Amount) / reserve1) * 1E4;\n        } else {\n            token0Amount = router.quote(token1Amount, reserve1, reserve0);\n            priceImpactBps = ((reserve0 - token0Amount) / reserve0) * 1E4;\n        }\n    }\n\n\n}\n"
    },
    "contracts/interface/swap/v2-periphery/IUniswapV2Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.2;\n\ninterface IUniswapV2Router {\n\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n    \n}"
    },
    "contracts/interface/swap/core/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/TripleSlopeModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.3;\n\nimport './interface/IInterestModel.sol';\n\ncontract TripleSlopeModel is IInterestModel {\n    /****************************\n     * POLICY CONSTANT SECTIONS *\n     ****************************/\n\n    uint256 public constant DENOM = 1e18;\n\n    uint256 public constant CEIL_SLOPE_1 = 60 * DENOM;\n    uint256 public constant CEIL_SLOPE_2 = 90 * DENOM;\n    uint256 public constant CEIL_SLOPE_3 = 100 * DENOM;\n\n    uint256 public constant MAX_INTEREST_SLOPE_1 = (20 * DENOM) / 100;\n    uint256 public constant MAX_INTEREST_SLOPE_2 = (20 * DENOM) / 100;\n    uint256 public constant MAX_INTEREST_SLOPE_3 = (150 * DENOM) / 100;\n\n    /// @dev Intrest Rate per Second 계산하여 반환\n    /// @dev 가동률 = debt / (debt + floating)\n    /// @param debt 대출되어 나간돈\n    /// @param floating 대기자금\n    /// @return IR per 365days, denominator = 1e18\n    function calcInterestRate(uint256 debt, uint256 floating)\n        external\n        pure\n        override\n        returns (uint256)\n    {\n        if (debt == 0 || floating == 0) return 0;\n\n        uint256 total = debt + floating;\n        uint256 utilization = (debt * (100 * DENOM)) / (total);\n\n        // 구간별 이자율\n        if (utilization < CEIL_SLOPE_1) {\n            // utilization(0~60%) - 0%~20% APY\n            return\n                (utilization * MAX_INTEREST_SLOPE_1) / CEIL_SLOPE_1 / 365 days;\n        } else if (utilization < CEIL_SLOPE_2) {\n            // utilization(60%~90%) - 20% APY\n            return uint256(MAX_INTEREST_SLOPE_2) / 365 days;\n        } else if (utilization < CEIL_SLOPE_3) {\n            // utilization(90%~100%) - 20%~150% APY\n            return\n                (MAX_INTEREST_SLOPE_2 +\n                    ((utilization - CEIL_SLOPE_2) *\n                        (MAX_INTEREST_SLOPE_3 - MAX_INTEREST_SLOPE_2)) /\n                    (CEIL_SLOPE_3 - CEIL_SLOPE_2)) / 365 days;\n        } else {\n            // 그 외 모든 상황 - 150% APY\n            // 사실상 이 조건으로 들어올 수 없음\n            return MAX_INTEREST_SLOPE_3 / 365 days;\n        }\n    }\n}\n"
    },
    "contracts/interface/_IEvmoSwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// !! THIS FILE WAS AUTOGENERATED BY abi-to-sol v0.6.5. SEE SOURCE BELOW. !!\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IEvmoSwapRouter {\n    function WETH() external view returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        returns (\n            uint256 amountA,\n            uint256 amountB,\n            uint256 liquidity\n        );\n\n    function addLiquidityETH(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    )\n        external\n        payable\n        returns (\n            uint256 amountToken,\n            uint256 amountETH,\n            uint256 liquidity\n        );\n\n    function factory() external view returns (address);\n\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint256 pairFee\n    ) external pure returns (uint256 amountIn);\n\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut,\n        uint256 pairFee\n    ) external pure returns (uint256 amountOut);\n\n    function getAmountsIn(uint256 amountOut, address[] memory path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, address[] memory path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) external pure returns (uint256 amountB);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityETH(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountETH);\n\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountETHMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountETH);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function swapETHForExactTokens(\n        uint256 amountOut,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapTokensForExactETH(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    receive() external payable;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}